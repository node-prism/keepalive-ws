var r=class{constructor(i=2**16-1){this.ids=[];this.index=0;this.maxIndex=i}release(i){if(i<0||i>this.maxIndex)throw new TypeError(`ID must be between 0 and ${this.maxIndex}. Got ${i}.`);this.ids[i]=!1}reserve(){let i=this.index;for(;;){let e=this.index;if(!this.ids[e])return this.ids[e]=!0,e;if(this.index>=this.maxIndex?this.index=0:this.index++,this.index===i)throw new Error("All IDs are reserved. Make sure to release IDs when they are no longer used.")}}};var l=class{constructor(i,e){this.value=i,this.expireTime=Date.now()+e}get expiresIn(){return this.expireTime-Date.now()}get isExpired(){return Date.now()>this.expireTime}},d=class{constructor(){this.items=[]}add(i,e){this.items.push(new l(i,e))}get isEmpty(){let i=this.items.length;for(;i--;)if(this.items[i].isExpired)this.items.splice(i,1);else return!1;return!0}pop(){for(;this.items.length;){let i=this.items.shift();if(!i.isExpired)return i}return null}};var a=class extends EventTarget{constructor(e){super();this.ids=new r;this.queue=new d;this.callbacks={};this.socket=e,this.applyListeners()}on(e,n,s){this.addEventListener(e,n,s)}off(e,n,s){this.removeEventListener(e,n,s)}sendToken(e,n){try{this.socket.send(JSON.stringify(e))}catch{this.queue.add(e,n)}}applyListeners(e=!1){let n=()=>{for(;!this.queue.isEmpty;){let s=this.queue.pop();this.sendToken(s.value,s.expiresIn)}};e&&n(),this.socket.onopen=(s,t)=>{n(),this.dispatchEvent(new Event("connection")),this.dispatchEvent(new Event("connected")),this.dispatchEvent(new Event("connect"))},this.socket.onclose=s=>{this.dispatchEvent(new Event("close")),this.dispatchEvent(new Event("closed")),this.dispatchEvent(new Event("disconnected")),this.dispatchEvent(new Event("disconnect"))},this.socket.onmessage=async s=>{try{let t=JSON.parse(s.data);this.dispatchEvent(new CustomEvent("message",{detail:t})),t.command==="latency:request"?(this.dispatchEvent(new CustomEvent("latency:request",{detail:{latency:t.payload.latency??void 0}})),this.command("latency:response",{latency:t.payload.latency??void 0},null)):t.command==="latency"?this.dispatchEvent(new CustomEvent("latency",{detail:{latency:t.payload??void 0}})):t.command==="ping"?(this.dispatchEvent(new CustomEvent("ping",{})),this.command("pong",{},null)):this.dispatchEvent(new CustomEvent(t.command,{detail:t.payload})),this.callbacks[t.id]&&this.callbacks[t.id](null,t.payload)}catch{this.dispatchEvent(new Event("error"))}}}async command(e,n,s=3e4,t=null){let c=this.ids.reserve(),v={id:c,command:e,payload:n??{}};if(this.sendToken(v,s),s===null){this.ids.release(c),delete this.callbacks[c];return}let p=this.createResponsePromise(c),m=this.createTimeoutPromise(c,s);if(typeof t=="function"){let u=await Promise.race([p,m]);return t(u),u}else return Promise.race([p,m])}createTimeoutPromise(e,n){return new Promise((s,t)=>{setTimeout(()=>{this.ids.release(e),delete this.callbacks[e],t(new Error(`Command ${e} timed out after ${n}ms.`))},n)})}createResponsePromise(e){return new Promise((n,s)=>{this.callbacks[e]=(t,c)=>{this.ids.release(e),delete this.callbacks[e],t?s(t):n(c)}})}};var E=(o={})=>(o.pingTimeout=o.pingTimeout??3e4,o.maxLatency=o.maxLatency??2e3,o.shouldReconnect=o.shouldReconnect??!0,o.reconnectInterval=o.reconnectInterval??2e3,o.maxReconnectAttempts=o.maxReconnectAttempts??1/0,o),h=class extends EventTarget{constructor(e,n={}){super();this.isReconnecting=!1;this.url=e,this.socket=new WebSocket(e),this.connection=new a(this.socket),this.options=E(n),this.applyListeners()}get on(){return this.connection.addEventListener.bind(this.connection)}applyListeners(){this.connection.addEventListener("connection",()=>{this.heartbeat()}),this.connection.addEventListener("close",()=>{this.reconnect()}),this.connection.addEventListener("ping",()=>{this.heartbeat()}),this.connection.addEventListener("message",e=>{this.dispatchEvent(new CustomEvent("message",e))})}heartbeat(){clearTimeout(this.pingTimeout),this.pingTimeout=setTimeout(()=>{this.options.shouldReconnect&&this.reconnect()},this.options.pingTimeout+this.options.maxLatency)}async reconnect(){if(this.isReconnecting)return;this.isReconnecting=!0;let e=1;if(this.socket)try{this.socket.close()}catch{}let n=()=>{this.socket=new WebSocket(this.url),this.socket.onerror=()=>{e++,e<=this.options.maxReconnectAttempts?setTimeout(n,this.options.reconnectInterval):(this.isReconnecting=!1,this.connection.dispatchEvent(new Event("reconnectfailed")),this.connection.dispatchEvent(new Event("reconnectionfailed")))},this.socket.onopen=()=>{this.isReconnecting=!1,this.connection.socket=this.socket,this.connection.applyListeners(!0),this.connection.dispatchEvent(new Event("connection")),this.connection.dispatchEvent(new Event("connected")),this.connection.dispatchEvent(new Event("connect")),this.connection.dispatchEvent(new Event("reconnection")),this.connection.dispatchEvent(new Event("reconnected")),this.connection.dispatchEvent(new Event("reconnect"))}};n()}async command(e,n,s,t){return this.connection.command(e,n,s,t)}};export{a as Connection,h as KeepAliveClient};
